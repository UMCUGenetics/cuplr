---
title: "Identifying gene amplification and biallelic losses"
output: rmarkdown::github_document
---

geneDriverAnnotator is an R package designed to determine the amplification/biallelic loss status of 
a set of genes (provided as a bed file) based on copy number and SNV/indel data generated by the HMF
variant calling pipeline. 

## Getting started
### Generated by HMF pipeline
- Germline SNV/indel vcf (\*.annotated.vcf.gz)
- Somatic SNV/indel vcf (\*.purple.somatic.vcf.gz)
- Soamtic copy number info (\*.purple.cnv.somatic.tsv)

### Gene and exon list
- Genes bed file; with the chromosome/start/end coordinates, and ENSEMBL gene IDs of the desired 
genes

```{r error=FALSE, results="hide", echo=FALSE}
pkg_dir  <- '/Users/lnguyen/hpc/cuppen/projects/P0013_WGS_patterns_Diagn/CUPs_classifier/processed/cuplr/geneDriverAnnotator/'
```


```{r message=FALSE, warning=FALSE, echo=FALSE}
genes_bed <- read.delim(
   file=paste0(pkg_dir,'/inst/misc/genes_plusMinus100bp.txt.gz'),
   check.names=F
)
head(genes_bed)
```

- Exons bed file; similar as above, additionally with the ENSEMBL exon IDs

```{r message=FALSE, warning=FALSE, echo=FALSE}
exons_bed <- read.delim(
   file=paste0(pkg_dir,'/inst/misc/exons.txt.gz'),
   check.names=F
)
head(exons_bed)
```

## Usage
First install the package and its dependencies.
```{r eval=FALSE, error=FALSE}
## Install dependencies
install.packages('seqminer')

## Install geneDriverAnnotator
devtools::install_github('https://github.com/UMCUGenetics/cuplr/tree/master/geneDriverAnnotator')
```

`detGeneStatuses()` is the main function of the package. The user may specify the path to a
`bed.file`, but if unspecified, the one included in this package will be used. The user may also
optionally specify the path to the java binary (`java.path`; default is the one installed on the
system), as well as the path to the SnpSift jar (`snpsift.path`; default is the jar included at
`inst/dep/SnpSift.jar`).

```{r eval=FALSE, error=FALSE}
detGeneStatuses(
   out.dir='/path/to/write/output/files/', 
   input.file.paths=c(
   	 germ_vcf='/path/to/annotated.vcf.gz', 
   	 som_vcf='/path/to/purple.somatic.vcf.gz', 
   	 cnv='/path/to/purple.cnv.somatic.tsv'
   ), 
   sample.name='sample_name',
   
   ## Optional arguments
   genes.bed.file='/path/to/genes/bed/file',
   exons.bed.file='/path/to/exons/bed/file',
   java.path='/path/to/java/binary', 
   snpsift.path='/path/to/snpsift/jar',
   snpeff.path='/path/to/snpeff/jar',
   
   do.filter.vcf=T, ## Filter vcfs for PASS variants and variants in the bed file regions?
   do.snpeff.ann=F,## Annotate variants with snpeff? Must be TRUE if vcf is not yet annotated
   keep.chroms=c(1:22,'X'), ## Genes in chromosomes to keep
   
   verbose=T
)
```

The output is a table where each row contains (1) data about copy number
gains at the chromosome arm level relative to the genome ploidy, and local copy number gains
relative to the chromosome arm ploidy; (2) data about losses/mutations of allele 1 and allele 2, with
each variant being given an impact score from 0-5 based on ClinVar annotations (has priority) or
SnpEff variant type annotations. Below is a schematic overview of the output table.


```
      || gene metadata || CN gain info || allele 1 losses/muts        || allele 2 losses/muts        ||
      ||               ||              || variant type | impact score || variant type | impact score ||
------------------------------------------------------------------------------------------------------
gene1 ||               ||              ||              |              ||              |              ||
gene2 ||               ||              ||              |              ||              |              ||
 ...

```

## Package workflow
### Pre-processing HMF pipeline outputs
* Calculate ploidy for each chromosome arm
* Subset cnv table for regions of genes of interest
* Subset germline and somatic vcfs using SnpSift for regions of genes of interest

### Identify amplifications
* Calculate gains relative to genome, arm ploidy or if the amp is focal
```
gain type         | formula
------------------------------------
gain_ratio_genome | min_copy_number / genome_ploidy
gain_ratio_arm    | arm_ploidy / genome_ploidy
gain_ratio_focal  | min_copy_number / arm_ploidy
```

* Determine highest gain type. If arm gain, check if whole chromosome has a gain.
* Assign the one of the following amp types: none, arm, chrom, focal

### Assign scores for CN loss events
* If min copy number < 0.3: flag as deep deletion. Assign score of 5+5
* Else if max copy number < 0.3: flag as truncation. Assign score of 5+5
* Else if min minor allele ploidy < 0.2: flag as LOH. Assign score of 5 to allele 1
* Else flag as no copy number variant

### Assign scores to SNV/indels
* Flag origin of variant (i.e. germline or somatic)
* Assign score to mutations in each allele based on Clinvar or SnpEff annotations:

```
score | ClinVar           | Snpeff
-----------------------------------------------------------
  5   | pathogenic        | frameshift
  4   | likely_pathogenic | nonsense
  3   | VUS               | missense, splice, inframe indel
  2   | likely_benign     | other variants
  1   | benign            | other variants
  0   | no data available | other variants
```

### Combine monoallelic events
* If deep deletion or truncation, assign gene CNV output to both allele 1 and 2
* Else make pairs of the following events: LOH, germline mut, somatic mut
* Determine variant pair with the highest hit score (i.e. combined score). The order of in which
biallelic event types are prioritized is described below.

```
biallelic event | allele1 event | allele2 event 
-----------------------------------------------
CN loss         | deep deletion | deep deletion
CN loss         | truncation    | truncation
LOH+som         | LOH           | SNV/indel
LOH+germ        | LOH           | SNV/indel
som+som         | SNV/indel     | SNV/indel
germ+som        | SNV/indel     | SNV/indel
```

### Output
* A table containing for each gene: (1) the maximum impact variant pair; and (2) the amplification data

```{r error=FALSE, results="hide", echo=FALSE}
file.copy(
   paste0(pkg_dir,'/doc/README.md'),
   paste0(pkg_dir,'/README.md'),
   overwrite=T
)
##file.remove(paste0(pkg_dir,'/doc/README.md'))
```
