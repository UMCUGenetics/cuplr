% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nmf.R
\name{nmfRankSearch}
\alias{nmfRankSearch}
\title{Non-negative matrix factorization}
\usage{
nmfRankSearch(
  A,
  k.range = 1:10,
  repeats = 50,
  max.samples = 100,
  impute.prop = 0.1,
  max.rel.log.mse.increase = 0.002,
  run.with.optimum.k = T,
  seed = 1,
  verbose = 0
)
}
\arguments{
\item{A}{A numeric matrix (rows=samples, columns=features)}

\item{k.range}{Integer vector. A range of ranks in which to find the optimum rank}

\item{repeats}{See description}

\item{max.samples}{Subsample number of rows to this value to reduce computation time}

\item{impute.prop}{See description}

\item{max.rel.log.mse.increase}{See description}

\item{seed}{Random seed}

\item{verbose}{Show progress? Can be 0,1,2}

\item{repeat.num}{Only used to label the repeat number in the output dataframe of `runNmf()`}

\item{perf.metrics}{Can be 'mse_imputed' (calculate MSE on imputed values) or 'mse_perm'
(calculate MSE on permuted data)}

\item{return.perf}{Only for `runNmf()`. If TRUE will return a dataframe with performance stats.
If FALSE, the output of `NNLM::nnmf()` as well as performance stats willbe returned}
}
\value{
A list containing the factorized matrices and MSE values from rank search
}
\description{
A wrapper function around NNLM::nnmf() to extract signatures from a numeric matrix
(where columns are features and rows are samples).

The function determines the optimum NMF rank by first setting a portion of values
(`impute.prop`) in the input matrix to NA, which triggers value imputation from NNLM::nnmf(). A
mean squared error (MSE) between the original and imputed values is determined. The above
procedure is repeated several times (`repeats`), after which median MSE values are calculated.
The optimum rank is in theory the rank at which MSE is minimum, however in practice, this is
the rank before which MSE increases by a certain threshold (`max.rel.log.mse.increase`).
}
